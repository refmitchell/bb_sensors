<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>bb_sensors: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">bb_sensors Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>bb_sensors</b> provides the nodes and libraries required for reading from the sensor system on the beetlebot.</p>
<p>All of this code is designed to be run on-board (i.e. on the Raspberry Pi board of the BeetleBot platform). For more information see below, or use the file list (drop down menu above).</p>
<p>List of nodes:</p><ul>
<li><b>camera</b> </li>
<li><b>i2c_mux</b> </li>
<li><b>pol_op_mux</b> </li>
<li><b>pol_op_read</b> </li>
</ul>
<hr  />
<h1><a class="anchor" id="desc"></a>
Node descriptions</h1>
<h2><a class="anchor" id="camera"></a>
camera</h2>
<p>The camera node reads a downsamples image from a connected Raspberry Pi camera module and then broadcasts this on the <code>/frames</code> topic. Image downsampling is set at compile time and cannot be configured at run time. If the node starts successfully "Publishing..." will be displayed in the terminal window.</p>
<h3><a class="anchor" id="Usage"></a>
Usage</h3>
<pre class="fragment">$ rosrun bb_sensors camera
</pre><h3><a class="anchor" id="topics"></a>
ROS topics</h3>
<p>Subscribes to:</p><ul>
<li>None</li>
</ul>
<p>Publishes to:</p><ul>
<li><b><code>/frames</code></b>: [sensor_msgs/Image] Raw image data from the camera.</li>
</ul>
<h3><a class="anchor" id="parameters"></a>
ROS parameters</h3>
<p>This node does not interact with the parameter server.</p>
<h3><a class="anchor" id="services"></a>
ROS services</h3>
<p>This node does not interact with any ROS services.</p>
<h2><a class="anchor" id="i2c_mux"></a>
i2c_mux</h2>
<p>The i2c_mux node is badly named. This node is reads data from a custom-built wind sensor over I2C. The node reads from two AS5600 magnetic encoders, one of which gives wind speed and the other direction. As the encoders are the same, an I2C mux is used to read from both in sequence (hence the node name).</p>
<h3><a class="anchor" id="Usage"></a>
Usage</h3>
<pre class="fragment">$ rosrun bb_sensors i2c_mux
</pre><p>Once the node is started, use rostopic list to check that teh <code>wind_speed</code> and <code>wind_direction</code> topics have registered.</p>
<h3><a class="anchor" id="topics"></a>
ROS topics</h3>
<p>Subscribes to:</p><ul>
<li>None</li>
</ul>
<p>Publishes to:</p><ul>
<li><b><code>/wind_speed</code></b>: [std_msgs/Float64] wind speed information.</li>
<li><b><code>/wind_direction</code></b>: [std_msgs/Float64] wind direction information (in degrees).</li>
</ul>
<h3><a class="anchor" id="parameters"></a>
ROS parameters</h3>
<p>This node does not interact with the parameter server.</p>
<h3><a class="anchor" id="services"></a>
ROS services</h3>
<p>This node does not interact with any ROS services.</p>
<h2><a class="anchor" id="pol_op_mux"></a>
pol_op_mux</h2>
<p>This node reads from the polarisation sensor constructed for Gkanias et al. (2023). The node reads from each polarisation opponent unit in sequence and broadcasts the resultant photodiode readings to the network. Note that the node does no processing of polarisation and only provides the raw photodiode readings.</p>
<h3><a class="anchor" id="Usage"></a>
Usage</h3>
<pre class="fragment">$ rosrun bb_sensors pol_op_mux -n N
</pre><p><code>N</code> is the number of polarisation opponent units in use. The sensor is constructed of eight units but the default is <code>N = 1</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If you are planning to use the polarisation sensor and this read code there are two main things to be aware of. </dd>
<dd>
<ol type="1">
<li>This code is <b>slow</b>; there is a lot of latency in reading from the photodiodes and the delays which have been included in the read stages are as low as they can be without returning erroneous readings.</li>
<li>The polarisation opponent units are read <b>in</b> <b>sequence</b> and that sequence is defined by the hardware (the channel indices on the I2C mux). Thus, the order in which individual sensors are read is dictated by the channel they are connected to on the I2C mux. You need to carefully note which channel each unit is connected to in order to correctly compute the position of the sun using the sensor. </li>
</ol>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ADC we use is the ADS112C04 by Texas Instruments. The library for the ADC was adapted from a previous Arduino library for the ADS122C04 (112 vs. 122). As a result, the device is erroneously called the ADS122C04 throughout the code. I was not able to fix this without introducing major changes (which invariably introduce major bugs); I was worried about breaking something which I then wouldn't have time to test. Please be aware of this difference if you plan to modify any of the I2C libraries for this device! </dd></dl>
<h3><a class="anchor" id="topics"></a>
ROS topics</h3>
<p>Subscribes to:</p><ul>
<li>None</li>
</ul>
<p>Publishes to:</p><ul>
<li><code>\pol_op_n</code>: [std_msgs:Int32MultiArray] An array of four photodiode readings from polarisation opponent unit <code>n</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>There will be one topic for each unit (indexed from 0). For example, if you start the node with: <pre class="fragment">rosrun bb_sensors pol_op_mux -n 4
</pre> Then <code>/pol_op_0</code>, <code>/pol_op_1</code>, <code>/pol_op_2</code>, and <code>/pol_op_3</code> should all appear as topics.</dd></dl>
<h3><a class="anchor" id="parameters"></a>
ROS parameters</h3>
<p>This node does not interact with the parameter server.</p>
<h3><a class="anchor" id="services"></a>
ROS services</h3>
<p>This node does not interact with any ROS services.</p>
<h2><a class="anchor" id="pol_op_read"></a>
pol_op_read</h2>
<p>This is a test node designed to read from a single polarisation opponent device (one of those used to construct the polarisation sensor described in Gkanias et al. (2023)). The node assumes that the unit is wired directly onto the I2C bus of the RPi and</p>
<h3><a class="anchor" id="Usage"></a>
Usage</h3>
<pre class="fragment">$ rosrun bb_sensors pol_op_mux
</pre><p>The current working state of this node is unknown as it has not been used since the early prototyping stages of polarisation sensor development.</p>
<h3><a class="anchor" id="topics"></a>
ROS topics</h3>
<p>This node does not publish or subscribe to any ROS topics.</p>
<h3><a class="anchor" id="parameters"></a>
ROS parameters</h3>
<p>This node does not interact with the parameter server.</p>
<h3><a class="anchor" id="services"></a>
ROS services</h3>
<p>This node does not interact with any ROS services.</p>
<h3><a class="anchor" id="Usage"></a>
Usage</h3>
<pre class="fragment">$ rosrun bb_sensors pol_op_read
</pre><p>The current working state of this node is unknown as it has not been used since the early prototyping stages of polarisation sensor development.</p>
<h3><a class="anchor" id="topics"></a>
ROS topics</h3>
<p>This node does not publish or subscribe to any ROS topics.</p>
<h3><a class="anchor" id="parameters"></a>
ROS parameters</h3>
<p>This node does not interact with the parameter server.</p>
<h3><a class="anchor" id="services"></a>
ROS services</h3>
<p>This node does not interact with any ROS services.</p>
<h2><a class="anchor" id="pol_op_read"></a>
pol_op_read</h2>
<p>This is a test node designed to read from a single polarisation opponent device (one of those used to construct the polarisation sensor described in Gkanias et al. (2023)). The node assumes that the unit is wired directly onto the I2C bus of the RPi and</p>
<h3><a class="anchor" id="Usage"></a>
Usage</h3>
<pre class="fragment">$ rosrun bb_sensors pol_op_read
</pre><p>The current working state of this node is unknown as it has not been used since the early prototyping stages of polarisation sensor development.</p>
<h3><a class="anchor" id="topics"></a>
ROS topics</h3>
<p>This node does not publish or subscribe to any ROS topics.</p>
<h3><a class="anchor" id="parameters"></a>
ROS parameters</h3>
<p>This node does not interact with the parameter server.</p>
<h3><a class="anchor" id="services"></a>
ROS services</h3>
<p>This node does not interact with any ROS services.</p>
<h1><a class="anchor" id="commandline"></a>
Command-line tools</h1>
<p>No command-line tools are provided by this package</p>
<h2><a class="anchor" id="script_name"></a>
script_name</h2>
<p>No additional scripts are provided by this package. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

<br clear="all" />
<hr size="1"><div style="align: right;">
<a href="http://wiki.ros.org/bb_sensors">bb_sensors</a><br />
Author(s): </br />
<small>autogenerated on Sat Aug 12 2023 14:44:53</small>
</div>
</body>
</html>
